一个页面对应一个watcher,取值时给每个属性添加一个dep,dep中记录着这个属性在那个组件中使用过，watcher记录当前组件有哪些dep，
也就是记录着当前页面使用过哪些属性，如果属性改变就调用watcher中当前组件的更新方法，

watch 原理，在wath中取一次值，被get拦截，然后放到将wathcer当到dep中，该wather并不是组件wathcer,
而是该属性对应的watcher
这次取的值就是老值，然后数据更新再次执行获取函数，获得新值，这时调用用户传入的回调函数，传入新老值
一个属性对应一个watcher,这个watcher，被一个dep记录起来，更新函数就是调用wacthr的run方法

computed 原理
computed传入先回被当前实例代理get方法是传入的函数这样就能获取到值了，然后加入到响应系统里如果值没改变就直接返会
计算好的数据如果改变了就重新获取值，执行get函数


diff算法
怎么比？ 先比较标签名如果不一样就直接替换，如果一样就比较属性，事件，比较儿子递归比较，
谁和谁比？尽量让上一个的老节点复用，在新节列中如果存在和老节点标签名相同并且key也相同就让这两个节点对比，如果没有
key，就只会用标签名判断这个节点是不是可以复用，
怎么找可以复用的节点？新虚拟节列点和老虚拟节点列，起点和起点比较标签名是否相同 并且key相同，如果相同就开始对比，不同
就让，新老虚拟节点列终点判断标签名是否相同 并且key相同，然后尾头对比，头尾对比，如果key都不一样就用乱序对比算发

next()原理
把所有的事件放到一个数组里，然后用微任务promise.resolve().then(fn)fn执行数组里的函数，更新操作第一个放到数组里所以才
是更新后

